<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CPIDataBase · HEMI</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://die-bg.github.io/HEMI.jl/modules/CPIDataBase/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="HEMI logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="HEMI logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HEMI</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Acerca</a></li><li><a class="tocitem" href="../../guides/Guia-rapida/">Guía rápida</a></li><li><span class="tocitem">Ejemplos</span><ul><li><a class="tocitem" href="../../generated/explore_data/">Carga de datos y exploración de estructuras</a></li></ul></li><li><a class="tocitem" href="../../guides/Guia-evaluacion/">Guía de evaluación</a></li><li><span class="tocitem">Evaluación</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Escenario A</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../eval/EscA/evaluacion-percentiles/">Percentiles</a></li><li><a class="tocitem" href="../../eval/EscA/evaluacion-MT/">Medias truncadas</a></li><li><a class="tocitem" href="../../eval/EscA/evaluacion-dynEx/">Exclusión dinámica</a></li><li><a class="tocitem" href="../../eval/EscA/evaluacion-exclusion-fija/">Exclusión fija de gastos básicos</a></li><li><a class="tocitem" href="../../eval/EscA/evaluacion-MAI/">Subyacente MAI</a></li><li><a class="tocitem" href="../../eval/EscA/evaluacion-MediaSimple/">Media Simple</a></li><li><a class="tocitem" href="../../eval/EscA/evaluacion-MediaPonderada/">Media Ponderada</a></li><li><a class="tocitem" href="../../eval/EscA/evaluacion-suavizamiento-exponencial/">Suavizamiento exponencial</a></li><li><a class="tocitem" href="../../eval/EscA/evaluacion-combinacion-lineal-mse/">Combinación lineal MSE</a></li><li><a class="tocitem" href="../../eval/EscA/evaluacion-mse-validacion-cruzada/">Ejercicio de validación cruzada y prueba de combinación lineal MSE</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Escenario B</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../eval/EscB/evaluacion-percentiles/">Percentiles</a></li><li><a class="tocitem" href="../../eval/EscB/evaluacion-MT/">Medias truncadas</a></li><li><a class="tocitem" href="../../eval/EscB/evaluacion-dynEx/">Exclusión dinámica</a></li><li><a class="tocitem" href="../../eval/EscB/evaluacion-exclusion-fija/">Exclusión fija de gastos básicos</a></li><li><a class="tocitem" href="../../eval/EscB/evaluacion-MAI/">Subyacente MAI</a></li><li><a class="tocitem" href="../../eval/EscB/evaluacion-MediaSimple/">Media Simple</a></li><li><a class="tocitem" href="../../eval/EscB/evaluacion-MediaPonderada/">Media Ponderada</a></li><li><a class="tocitem" href="../../eval/EscB/evaluacion-suavizamiento-exponencial/">Suavizamiento exponencial</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Escenario C</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../eval/EscC/evaluacion-percentiles/">Percentiles</a></li><li><a class="tocitem" href="../../eval/EscC/evaluacion-dynEx/">Exclusión dinámica</a></li><li><a class="tocitem" href="../../eval/EscC/evaluacion-MT/">Medias truncadas</a></li><li><a class="tocitem" href="../../eval/EscC/evaluacion-exclusion-fija/">Exclusión fija de gastos básicos</a></li><li><a class="tocitem" href="../../eval/EscC/evaluacion-MAI/">Subyacente MAI</a></li><li><a class="tocitem" href="../../eval/EscC/evaluacion-MediaSimple/">Media Simple</a></li><li><a class="tocitem" href="../../eval/EscC/evaluacion-MediaPonderada/">Media Simple</a></li><li><a class="tocitem" href="../../eval/EscC/evaluacion-suavizamiento-exponencial/">Suavizamiento exponencial</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Escenario D</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../eval/EscD/evaluacion-percentiles/">Percentiles</a></li><li><a class="tocitem" href="../../eval/EscD/evaluacion-MT/">Medias truncadas</a></li><li><a class="tocitem" href="../../eval/EscD/evaluacion-MAI/">Subyacente MAI</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Escenario E</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../eval/EscE/evaluacion-percentiles/">Percentiles</a></li><li><a class="tocitem" href="../../eval/EscE/evaluacion-MT/">Medias truncadas</a></li><li><a class="tocitem" href="../../eval/EscE/evaluacion-MAI/">Subyacente MAI</a></li><li><a class="tocitem" href="../../eval/EscE/evaluacion-combinacion-lineal-mse/">Combinación lineal MSE</a></li></ul></li></ul></li><li><span class="tocitem">Resultados 2020</span><ul><li><a class="tocitem" href="../../eval/2020/combinacion-lineal-mse/">Combinación lineal MSE</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../HEMI/">HEMI</a></li><li class="is-active"><a class="tocitem" href>CPIDataBase</a></li><li><a class="tocitem" href="../InflationFunctions/">InflationFunctions</a></li><li><a class="tocitem" href="../InflationEvalTools/">InflationEvalTools</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>CPIDataBase</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CPIDataBase</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DIE-BG/HEMI.jl/blob/master/docs/src/modules/CPIDataBase.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CPIDataBase"><a class="docs-heading-anchor" href="#CPIDataBase">CPIDataBase</a><a id="CPIDataBase-1"></a><a class="docs-heading-anchor-permalink" href="#CPIDataBase" title="Permalink"></a></h1><ul><li><a href="#CPIDataBase.CPIDataBase"><code>CPIDataBase.CPIDataBase</code></a></li><li><a href="#CPIDataBase.AbstractCPIBase"><code>CPIDataBase.AbstractCPIBase</code></a></li><li><a href="#CPIDataBase.CODETYPE"><code>CPIDataBase.CODETYPE</code></a></li><li><a href="#CPIDataBase.CPIIndex"><code>CPIDataBase.CPIIndex</code></a></li><li><a href="#CPIDataBase.CPIResult"><code>CPIDataBase.CPIResult</code></a></li><li><a href="#CPIDataBase.CPITree"><code>CPIDataBase.CPITree</code></a></li><li><a href="#CPIDataBase.CPIVarInterm"><code>CPIDataBase.CPIVarInterm</code></a></li><li><a href="#CPIDataBase.CombinationFunction"><code>CPIDataBase.CombinationFunction</code></a></li><li><a href="#CPIDataBase.CountryStructure"><code>CPIDataBase.CountryStructure</code></a></li><li><a href="#CPIDataBase.DATETYPE"><code>CPIDataBase.DATETYPE</code></a></li><li><a href="#CPIDataBase.DESCTYPE"><code>CPIDataBase.DESCTYPE</code></a></li><li><a href="#CPIDataBase.EnsembleFunction"><code>CPIDataBase.EnsembleFunction</code></a></li><li><a href="#CPIDataBase.EnsembleInflationFunction"><code>CPIDataBase.EnsembleInflationFunction</code></a></li><li><a href="#CPIDataBase.FullCPIBase-Tuple{DataFrame, DataFrame}"><code>CPIDataBase.FullCPIBase</code></a></li><li><a href="#CPIDataBase.FullCPIBase"><code>CPIDataBase.FullCPIBase</code></a></li><li><a href="#CPIDataBase.Group"><code>CPIDataBase.Group</code></a></li><li><a href="#CPIDataBase.IndexCPIBase"><code>CPIDataBase.IndexCPIBase</code></a></li><li><a href="#CPIDataBase.IndexCPIBase-Tuple{DataFrame, DataFrame}"><code>CPIDataBase.IndexCPIBase</code></a></li><li><a href="#CPIDataBase.InflationCombination"><code>CPIDataBase.InflationCombination</code></a></li><li><a href="#CPIDataBase.InflationEnsemble"><code>CPIDataBase.InflationEnsemble</code></a></li><li><a href="#CPIDataBase.InflationFunction"><code>CPIDataBase.InflationFunction</code></a></li><li><a href="#CPIDataBase.Item"><code>CPIDataBase.Item</code></a></li><li><a href="#CPIDataBase.MixedCountryStructure"><code>CPIDataBase.MixedCountryStructure</code></a></li><li><a href="#CPIDataBase.UniformCountryStructure"><code>CPIDataBase.UniformCountryStructure</code></a></li><li><a href="#CPIDataBase.VarCPIBase"><code>CPIDataBase.VarCPIBase</code></a></li><li><a href="#CPIDataBase.VarCPIBase-Tuple{DataFrame, DataFrame}"><code>CPIDataBase.VarCPIBase</code></a></li><li><a href="#CPIDataBase.capitalize"><code>CPIDataBase.capitalize</code></a></li><li><a href="#CPIDataBase.capitalize-Tuple{VarCPIBase}"><code>CPIDataBase.capitalize</code></a></li><li><a href="#CPIDataBase.capitalize!"><code>CPIDataBase.capitalize!</code></a></li><li><a href="#CPIDataBase.components-Tuple{CombinationFunction}"><code>CPIDataBase.components</code></a></li><li><a href="#CPIDataBase.components-Tuple{EnsembleFunction}"><code>CPIDataBase.components</code></a></li><li><a href="#CPIDataBase.compute_index-Tuple{CPITree, AbstractString}"><code>CPIDataBase.compute_index</code></a></li><li><a href="#CPIDataBase.cpi_tree_nodes-Tuple{Vector{&lt;:AbstractString}}"><code>CPIDataBase.cpi_tree_nodes</code></a></li><li><a href="#CPIDataBase.get_cpi_tree-Tuple{}"><code>CPIDataBase.get_cpi_tree</code></a></li><li><a href="#CPIDataBase.getdates-Tuple{Date, AbstractMatrix}"><code>CPIDataBase.getdates</code></a></li><li><a href="#CPIDataBase.getdates-Tuple{Date, Int64}"><code>CPIDataBase.getdates</code></a></li><li><a href="#CPIDataBase.getunionalltype-Tuple{MixedCountryStructure}"><code>CPIDataBase.getunionalltype</code></a></li><li><a href="#CPIDataBase.getunionalltype-Tuple{UniformCountryStructure}"><code>CPIDataBase.getunionalltype</code></a></li><li><a href="#CPIDataBase.infl_dates-Tuple{CountryStructure}"><code>CPIDataBase.infl_dates</code></a></li><li><a href="#CPIDataBase.infl_periods-Tuple{CountryStructure}"><code>CPIDataBase.infl_periods</code></a></li><li><a href="../InflationFunctions/#CPIDataBase.measure_name-Tuple{InflationDynamicExclusion}"><code>CPIDataBase.measure_name</code></a></li><li><a href="../InflationFunctions/#CPIDataBase.measure_name-Tuple{InflationTrimmedMeanEq}"><code>CPIDataBase.measure_name</code></a></li><li><a href="#CPIDataBase.measure_name-Tuple{InflationFunction}"><code>CPIDataBase.measure_name</code></a></li><li><a href="../InflationFunctions/#CPIDataBase.measure_name-Tuple{InflationPercentileWeighted}"><code>CPIDataBase.measure_name</code></a></li><li><a href="../InflationFunctions/#CPIDataBase.measure_name-Tuple{InflationPercentileEq}"><code>CPIDataBase.measure_name</code></a></li><li><a href="../InflationFunctions/#CPIDataBase.measure_name-Tuple{InflationTrimmedMeanWeighted}"><code>CPIDataBase.measure_name</code></a></li><li><a href="#CPIDataBase.measure_tag-Tuple{InflationFunction}"><code>CPIDataBase.measure_tag</code></a></li><li><a href="#CPIDataBase.num_measures-Tuple{InflationFunction}"><code>CPIDataBase.num_measures</code></a></li><li><a href="#CPIDataBase.params-Tuple{InflationFunction}"><code>CPIDataBase.params</code></a></li><li><a href="#CPIDataBase.periods-Tuple{VarCPIBase}"><code>CPIDataBase.periods</code></a></li><li><a href="#CPIDataBase.periods-Tuple{CountryStructure}"><code>CPIDataBase.periods</code></a></li><li><a href="#CPIDataBase.varinteran"><code>CPIDataBase.varinteran</code></a></li><li><a href="#CPIDataBase.varinteran!"><code>CPIDataBase.varinteran!</code></a></li><li><a href="#CPIDataBase.varinterm-Tuple{IndexCPIBase}"><code>CPIDataBase.varinterm</code></a></li><li><a href="#CPIDataBase.varinterm"><code>CPIDataBase.varinterm</code></a></li><li><a href="#CPIDataBase.varinterm!"><code>CPIDataBase.varinterm!</code></a></li><li><a href="#CPIDataBase.weights-Tuple{CombinationFunction}"><code>CPIDataBase.weights</code></a></li><li><a href="#CPIDataBase.TestHelpers.getbasedates"><code>CPIDataBase.TestHelpers.getbasedates</code></a></li><li><a href="#CPIDataBase.TestHelpers.getrandombase-Tuple{}"><code>CPIDataBase.TestHelpers.getrandombase</code></a></li><li><a href="#CPIDataBase.TestHelpers.getrandomcountryst"><code>CPIDataBase.TestHelpers.getrandomcountryst</code></a></li><li><a href="#CPIDataBase.TestHelpers.getrandomweights"><code>CPIDataBase.TestHelpers.getrandomweights</code></a></li><li><a href="#CPIDataBase.TestHelpers.getzerobase-Tuple{}"><code>CPIDataBase.TestHelpers.getzerobase</code></a></li><li><a href="#CPIDataBase.TestHelpers.getzerocountryst"><code>CPIDataBase.TestHelpers.getzerocountryst</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.CPIDataBase" href="#CPIDataBase.CPIDataBase"><code>CPIDataBase.CPIDataBase</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">CPIDataBase</code></pre><p>Librería base para tipos y funcionalidad básica para manejo de los datos desagregados del IPC a nivel de república. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.CODETYPE" href="#CPIDataBase.CODETYPE"><code>CPIDataBase.CODETYPE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const CODETYPE = Union{Vector{String}, Nothing}</code></pre><p>Tipos posibles para los códigos en el campo <code>codes</code> de un <a href="#CPIDataBase.FullCPIBase"><code>FullCPIBase</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.DATETYPE" href="#CPIDataBase.DATETYPE"><code>CPIDataBase.DATETYPE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const DATETYPE = Union{StepRange{Date, Month}, Vector{Date}}</code></pre><p>Tipos posibles para el campo de fechas <code>dates</code> de un <a href="#CPIDataBase.AbstractCPIBase"><code>AbstractCPIBase</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.DESCTYPE" href="#CPIDataBase.DESCTYPE"><code>CPIDataBase.DESCTYPE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const DESCTYPE = Union{Vector{String}, Nothing}</code></pre><p>Tipos posibles para los nombres en el campo <code>names</code> de un <a href="#CPIDataBase.FullCPIBase"><code>FullCPIBase</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.AbstractCPIBase" href="#CPIDataBase.AbstractCPIBase"><code>CPIDataBase.AbstractCPIBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractCPIBase{T &lt;: AbstractFloat}</code></pre><p>Tipo abstracto para representar conjuntos de colecciones de datos del IPC. </p><p>Vea también: <a href="#CPIDataBase.FullCPIBase"><code>FullCPIBase</code></a>, <a href="#CPIDataBase.VarCPIBase"><code>VarCPIBase</code></a> e <a href="#CPIDataBase.IndexCPIBase"><code>IndexCPIBase</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.CPIIndex" href="#CPIDataBase.CPIIndex"><code>CPIDataBase.CPIIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tipo concreto único para obtener el índice de una función de inflación</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.CPIResult" href="#CPIDataBase.CPIResult"><code>CPIDataBase.CPIResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tipo abstracto para manejar el despacho de las funciones de inflación</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.CPITree" href="#CPIDataBase.CPITree"><code>CPIDataBase.CPITree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CPITree

CPITree(base::FullCPIBase, tree::Union{Group, Item}, group_names::Vector{String}, group_codes::Vector{String})
CPITree(; base::FullCPIBase, groupsdf::DataFrame, characters::(NTuple{N, Int} where N), upperlevel_code = &quot;_0&quot;, upperlevel_name = &quot;IPC&quot;)</code></pre><p>Contenedor envolvente de un árbol jerárquico del IPC y los datos necesarios de los gastos básicos para computar cualquier jerarquía dentro del árbol. Permite visualizar y explorar la composición del IPC de un país, así como computar los índices de precios de las diferentes jerarquías de la estructura del IPC. Está compuesto por: </p><ul><li>Un objeto <code>base</code>, de tipo <a href="#CPIDataBase.FullCPIBase"><code>FullCPIBase</code></a>, el cual almacena las series de tiempo de los índices de los gastos básicos. </li><li>Un objeto <code>tree</code> que contiene la estructura de nodos del IPC.</li><li>El vector de nombres <code>group_names</code> de los grupos del árbol <code>tree</code>.</li><li>El vector de códigos <code>group_codes</code> de los grupos del árbol <code>tree</code>.</li></ul><p>El constructor simple requiere una estructura jerárquica de nodos como la devuelta por <a href="#CPIDataBase.get_cpi_tree-Tuple{}"><code>get_cpi_tree</code></a>. Al utilizar el constructor con <code>groupsdf</code> y <code>characters</code>, se construye automáticamente un <code>CPITree</code> utilizando los códigos como indicadores de la estructura jerárquica. Los códigos de los gastos básicos contenidos en <code>base</code> describen cómo se agrupan las jerarquías. Por ejemplo, el siguiente <code>FullCPIBase</code> contiene 10 gastos básicos: </p><pre><code class="language-julia-repl hljs">julia&gt; base
FullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03
┌─────┬────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│ Row │      Dates │ _011101 │ _011201 │ _011202 │ _021101 │ _022101 │ _031101 │ _041101 │ _041201 │ _041202 │ _041301 │
│     │            │  Item A │  Item B │  Item C │  Item D │  Item E │  Item F │  Item G │  Item H │  Item I │  Item J │
│     │            │ 11.8947 │ 2.39931 │ 7.80836 │ 1.58585 │  20.141 │ 12.0526 │ 9.56901 │ 14.6256 │ 15.0276 │ 4.89602 │
├─────┼────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│   1 │ 2001-01-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  101.13 │  100.00 │  100.00 │  100.51 │  100.00 │
│   2 │ 2001-02-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  102.28 │  100.00 │  100.00 │  101.02 │  100.00 │
│   3 │ 2001-03-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  103.44 │  100.00 │  100.00 │  101.53 │  100.00 │
│   4 │ 2001-04-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  104.61 │  100.00 │  100.00 │  102.05 │  100.00 │
│   5 │ 2001-05-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  105.79 │  100.00 │  100.00 │  102.56 │  100.00 │
│  ⋮  │     ⋮      │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │
│  32 │ 2003-08-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  143.39 │  100.00 │  100.00 │  117.59 │  100.00 │
│  33 │ 2003-09-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  145.02 │  100.00 │  100.00 │  118.19 │  100.00 │
│  34 │ 2003-10-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  146.66 │  100.00 │  100.00 │  118.79 │  100.00 │
│  35 │ 2003-11-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  148.32 │  100.00 │  100.00 │  119.39 │  100.00 │
│  36 │ 2003-12-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  150.00 │  100.00 │  100.00 │  120.00 │  100.00 │
└─────┴────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
                                                                                                         26 rows omitted</code></pre><p>En este ejemplo, el argumento debe especificarse como <code>characters = (3, 4, 5, 7)</code>, pues los códigos indican las jerarquías en el IPC de manera siguiente: </p><ul><li>Los primeros 3 caracteres indican la jerarquía de <em>división de gasto</em>. </li><li>El siguiente caracter indica la jerarquía de <em>agrupación de gasto</em>. </li><li>El siguiente caracter indica la jerarquía de <em>subgrupo de gasto</em>. </li><li>Los siguientes 2 caracteres indican el <em>número de gasto básico dentro de su grupo</em>. </li></ul><p>Por su parte, el DataFrame <code>groupsdf</code> debe tener la estructura mínima siguiente: </p><ul><li>La primera columna debe ser de tipo <code>String</code> y contiene los códigos de los grupos disponibles en la estructura del IPC. </li><li>La segunda columna debe ser de tipo <code>String</code> y contiene las descripciones o</li></ul><p>nombres de los grupos disponibles en la estructura del IPC. Por ejemplo, el DataFrame <code>groupsdf</code> puede verse de esta forma: </p><pre><code class="nohighlight hljs">17×2 DataFrame
 Row │ code    description 
     │ String  String      
─────┼─────────────────────
   1 │ _01     Div._01
   2 │ _02     Div._02
   3 │ _03     Div._03
   4 │ _04     Div._04
   5 │ _011    Agr._011
   6 │ _021    Agr._021
   7 │ _022    Agr._022
   8 │ _031    Agr._031
   9 │ _041    Agr._041
  10 │ _0111   Subgr._0111
  11 │ _0112   Subgr._0112
  12 │ _0211   Subgr._0211
  13 │ _0221   Subgr._0221
  14 │ _0311   Subgr._0311
  15 │ _0411   Subgr._0411
  16 │ _0412   Subgr._0412
  17 │ _0413   Subgr._0413</code></pre><p>Por ejemplo, al construir un <code>CPITree</code> con la estructura de códigos indicada anteriormente y el DataFrame de ejemplo, el árbol del IPC se puede ver de esta forma: </p><pre><code class="language-julia-repl hljs">julia&gt; tree = CPITree(; base, groupsdf, characters=(3,4,5,7))
CPITree{Group{Group{Group{Group{Item{Float32}, Float32}, Float32}, Float32}, Float32}} con datos
└─→ FullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03
_0: IPC [100.0]
├─ _01: Div._01 [21.491905]
│  └─ _011: Agr._011 [21.491905]
│     ├─ _0111: Subgr._0111 [7.352945]
│     │  └─ _011101: Item A [7.352945]
│     └─ _0112: Subgr._0112 [14.13896]
│        ├─ _011201: Item B [6.7442417]
│        └─ _011202: Item C [7.394718]
├─ _02: Div._02 [3.0530455]
│  ├─ _021: Agr._021 [1.1036392]
│  │  └─ _0211: Subgr._0211 [1.1036392]
│  │     └─ _021101: Item D [1.1036392]
│  └─ _022: Agr._022 [1.9494063]
│     └─ _0221: Subgr._0221 [1.9494063]
│        └─ _022101: Item E [1.9494063]
├─ _03: Div._03 [11.68543]
│  └─ _031: Agr._031 [11.68543]
│     └─ _0311: Subgr._0311 [11.68543]
│        └─ _031101: Item F [11.68543]
└─ _04: Div._04 [63.769615]
   └─ _041: Agr._041 [63.769615]
      ├─ _0411: Subgr._0411 [16.103952]
      │  └─ _041101: Item G [16.103952]
      ├─ _0412: Subgr._0412 [28.824577]
      │  ├─ _041201: Item H [11.367162]
      │  └─ _041202: Item I [17.457417]
      └─ _0413: Subgr._0413 [18.841085]
         └─ _041301: Item J [18.841085]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.CPIVarInterm" href="#CPIDataBase.CPIVarInterm"><code>CPIDataBase.CPIVarInterm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tipo concreto único para obtener la variación intermensual de una función de inflación</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.CombinationFunction" href="#CPIDataBase.CombinationFunction"><code>CPIDataBase.CombinationFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinationFunction{N, W} &lt;: EnsembleInflationFunction &lt;: InflationFunction

CombinationFunction(ensemble, weights [, name, tag])
CombinationFunction(inflfn1, inflfn2 [, ...], weights [, name, tag])</code></pre><p>Función de inflación para computar un promedio ponderado de un conjunto de <code>N</code> de medidas de inflación con tipo del vector de ponderaciones <code>W</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.CountryStructure" href="#CPIDataBase.CountryStructure"><code>CPIDataBase.CountryStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountryStructure{N, T &lt;: AbstractFloat}</code></pre><p>Tipo abstracto que representa el conjunto de bases del IPC de un país.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.EnsembleFunction" href="#CPIDataBase.EnsembleFunction"><code>CPIDataBase.EnsembleFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnsembleFunction{N} &lt;: EnsembleInflationFunction

EnsembleFunction(inflfn1, inflfn2 [, ...])</code></pre><p>Función de inflación para computar un conjunto de <code>N</code> de medidas de inflación simultáneamente utilizando las funciones <code>inflfn1, inflfn2, ...</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.EnsembleInflationFunction" href="#CPIDataBase.EnsembleInflationFunction"><code>CPIDataBase.EnsembleInflationFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnsembleInflationFunction &lt;: InflationFunction &lt;: InflationFunction</code></pre><p>Tipo abstracto para conformar conjuntos de medidas de inflación</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.FullCPIBase" href="#CPIDataBase.FullCPIBase"><code>CPIDataBase.FullCPIBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FullCPIBase{T, B} &lt;: AbstractCPIBase{T}

FullCPIBase(ipc::Matrix{T}, v::Matrix{T}, w::Vector{T}, dates::DATETYPE, baseindex::B, codes::CODETYPE, names::DESCTYPE) where {T, B}
FullCPIBase(df::DataFrame, gb::DataFrame)</code></pre><p>Contenedor completo para datos desagregados del IPC de un país. Se representa por:</p><ul><li>Matriz de índices de precios <code>ipc</code> que incluye la fila con los índices del número base. </li><li>Matriz de variaciones intermensuales <code>v</code>. En las filas contiene los períodos y en las columnas contiene los gastos básicos.</li><li>Vector de ponderaciones <code>w</code> de los gastos básicos.</li><li>Fechas correspondientes <code>dates</code> (por meses).</li><li>Índices base <code>baseindex</code>. </li><li>Códigos y nombres de los gastos básicos en <code>codes</code> y <code>names</code>.</li></ul><p>El tipo <code>T</code> representa el tipo de datos para representar los valores de punto flotante. El tipo <code>B</code> representa el tipo del campo <code>baseindex</code>; por ejemplo, <code>Float32</code> o <code>Vector{Float32}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.FullCPIBase-Tuple{DataFrame, DataFrame}" href="#CPIDataBase.FullCPIBase-Tuple{DataFrame, DataFrame}"><code>CPIDataBase.FullCPIBase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FullCPIBase(df::DataFrame, gb::DataFrame)</code></pre><p>Este método constructor devuelve una estructura <code>FullCPIBase</code> a partir de los DataFrames de índices de precios <code>df</code> y de descripción de los gastos básicos <code>gb</code>. </p><ul><li>El DataFrame <code>df</code> posee la siguiente estructura: <ul><li>Contiene en la primera columna las fechas o períodos de los datos. En las siguientes columnas, debe contener los códigos de cada una de las categorías o gastos básicos de la estructura del IPC, junto con la serie de tiempo con los índices de precios individuales. </li><li>En las filas del DataFrame contiene los períodos por meses. La primera fila del DataFrame se utiliza para obtener el índice base. Si el valor es el mismo para todos los gastos básicos, se tomará únicamente este valor escalar (por ejemplo 100.0 como un Float64). En algunos casos, es posible que no se disponga de la información completa, por lo que los índices base podrían ser diferentes entre sí. En este caso, <code>baseindex</code> almacenará el vector de índices base originales. </li><li>Un ejemplo de cómo puede verse este DataFrame es el siguiente: </li></ul></li></ul><pre><code class="nohighlight hljs">121×219 DataFrame
 Row │ Date         _011111  _011121  _011131  _011141  _011142  _011151  _011152 ⋯
     │ Date         Float64  Float64  Float64  Float64  Float64  Float64  Float64 ⋯
─────┼─────────────────────────────────────────────────────────────────────────────
   1 │ 2000-12-01   100.0    100.0    100.0    100.0    100.0    100.0    100.0   ⋯
   2 │ 2001-01-01   100.55   103.23   101.66   106.47   100.36   100.0    102.57   
   3 │ 2001-02-01   101.47   104.82   102.73   108.38   101.37   100.0    103.35   
   4 │ 2001-03-01   101.44   107.74   104.9    103.76   101.32   100.0    104.27   
   5 │ 2001-04-01   101.91   107.28   106.19   107.83   101.82   100.0    104.73  ⋯
   6 │ 2001-05-01   102.77   106.12   106.9    109.16   101.81   100.0    105.21   
   7 │ 2001-06-01   103.23   109.04   107.4    112.13   102.72   100.0    105.47   
   8 │ 2001-07-01   104.35   112.72   107.96   117.19   105.09   100.0    105.66   
  ⋮  │     ⋮          ⋮        ⋮        ⋮        ⋮        ⋮        ⋮        ⋮     ⋱
 114 │ 2010-05-01   218.45   501.39   200.28   477.5    179.0    215.0    164.16  ⋯
 115 │ 2010-06-01   219.28   503.35   203.88   476.26   180.94   214.02   164.97   
 116 │ 2010-07-01   219.1    503.78   205.19   478.34   181.78   217.6    165.9    
 117 │ 2010-08-01   218.52   507.45   206.87   486.72   181.51   223.76   166.46   
 118 │ 2010-09-01   218.9    505.8    206.45   501.23   182.04   228.34   166.04  ⋯
 119 │ 2010-10-01   219.51   504.41   205.78   504.4    182.35   221.98   166.3    
 120 │ 2010-11-01   219.11   509.63   205.41   502.88   182.16   217.01   166.34   
 121 │ 2010-12-01   218.79   511.38   205.09   506.04   182.14   218.63   165.99   
                                                   211 columns and 105 rows omitted</code></pre><ul><li>El DataFrame <code>gb</code> posee la siguiente estructura: <ul><li>La primera columna contiene los códigos de las columnas del DataFrame <code>df</code>. </li><li>La segunda columna contiene el nombre o la descripción de cada una de las categorías en las columnas de <code>df</code>. </li><li>Y finalmente, la tercer columna, debe contener las ponderaciones asociadas a cada una de las categorías o gastos básicos de las columnas de <code>df</code>.</li><li>Los nombres de las columnas no son tomados en cuenta, solamente el orden y los tipos.</li><li>Un ejemplo de cómo puede verse este DataFrame es el siguiente: </li></ul></li></ul><pre><code class="nohighlight hljs">218×3 DataFrame
 Row │ Code     GoodOrService                       Weight
     │ String   String                              Float64     
─────┼────────────────────────────────────────────────────────
   1 │ _011111  Arroz                               0.483952
   2 │ _011121  Pan                                 2.82638
   3 │ _011131  Pastas frescas y secas              0.341395
   4 │ _011141  Productos de tortillería            1.69133
  ⋮  │   ⋮                     ⋮                     ⋮
 216 │ _093111  Gastos por seguros                  0.236691
 217 │ _093121  Gastos por servicios funerarios     0.289885
 218 │ _094111  Gastos por servicios diversos pa…   0.151793
                                              211 rows omitted</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.Group" href="#CPIDataBase.Group"><code>CPIDataBase.Group</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Group{S,T}

Group(code, name, children::Vector{S}) where S
Group(code, name, children...)</code></pre><p>Representa un nodo de agrupación de cualquier nivel en la estructura de nodos del IPC. Puede almacenar gastos básicos u otros grupos de mayor jerarquía. Almacena el código del grupo, su nombre o descripción y su ponderación en el IPC. </p><p>Posee los campos: </p><ul><li><code>code</code>: almacena el código del grupo como un <code>String</code>.</li><li><code>name</code>: almacena el nombre del grupo como un <code>String</code>.</li><li><code>weight::T</code>: almacena la ponderación del grupo como un valor flotante de tipo <code>T</code>.</li><li><code>children::Vector{S}</code>: almacena el vector de nodos &quot;hijos&quot; de la estructura. Por ejemplo, este vector podría ser un vector de elementos <code>Item</code> para agrupar un conjunto de gastos básicos.</li></ul><p>Aunque este nodo será usualmente creado de manera automática por métodos como <a href="#CPIDataBase.CPITree"><code>CPITree</code></a>, se pueden crear estructuras jerárquicas manualmente. Por ejemplo, para crear un grupo: </p><pre><code class="language-julia-repl hljs">julia&gt; a = Item(&quot;_011201&quot;, &quot;Item B&quot;, 6.7442417f0)
Item{Float32}(&quot;_011201&quot;, &quot;Item B&quot;, 6.7442417f0)

julia&gt; b = Item(&quot;_011202&quot;, &quot;Item C&quot;, 7.394718f0)
Item{Float32}(&quot;_011202&quot;, &quot;Item C&quot;, 7.394718f0)

julia&gt; g = Group(&quot;_0112&quot;, &quot;Subgr._0112&quot;, a, b)
Group{Item{Float32}, Float32}
_0112: Subgr._0112 [14.13896] 
├─ _011201: Item B [6.7442417]
└─ _011202: Item C [7.394718]</code></pre><p>Ver también: <a href="#CPIDataBase.Item"><code>Item</code></a>, <a href="#CPIDataBase.CPITree"><code>CPITree</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.IndexCPIBase" href="#CPIDataBase.IndexCPIBase"><code>CPIDataBase.IndexCPIBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexCPIBase{T, B} &lt;: AbstractCPIBase{T}

IndexCPIBase(ipc::Matrix{T}, w::Vector{T}, dates::DATETYPE, baseindex::B) where {T, B}</code></pre><p>Contenedor genérico de índices de precios del IPC de un país. Se representa por:</p><ul><li>Matriz de índices de precios <code>ipc</code> que incluye la fila con los índices del númbero base. </li><li>Vector de ponderaciones <code>w</code> de los gastos básicos.</li><li>Fechas correspondientes <code>dates</code> (por meses).</li><li>Índices base <code>baseindex</code>. </li></ul><p>El tipo <code>T</code> representa el tipo de datos para representar los valores de punto flotante. El tipo <code>B</code> representa el tipo del campo <code>baseindex</code>; por ejemplo, <code>Float32</code> o <code>Vector{Float32}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.IndexCPIBase-Tuple{DataFrame, DataFrame}" href="#CPIDataBase.IndexCPIBase-Tuple{DataFrame, DataFrame}"><code>CPIDataBase.IndexCPIBase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IndexCPIBase(df::DataFrame, gb::DataFrame)</code></pre><p>Este constructor devuelve una estructura <code>IndexCPIBase</code> a partir del DataFrame  de índices de precios <code>df</code>, que contiene en las columnas las categorías o gastos  básicos del IPC y en las filas los períodos por meses. Las ponderaciones se obtienen  de la estructura <code>gb</code>, en la tercera columna de ponderaciones.</p><p>Para conocer la estructura de los DataFrames necesarios, vea también: <a href="#CPIDataBase.FullCPIBase"><code>FullCPIBase</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.InflationCombination" href="#CPIDataBase.InflationCombination"><code>CPIDataBase.InflationCombination</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InflationCombination &lt;: EnsembleInflationFunction &lt;: InflationFunction</code></pre><p>Alias para <a href="#CPIDataBase.CombinationFunction"><code>CombinationFunction</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.InflationEnsemble" href="#CPIDataBase.InflationEnsemble"><code>CPIDataBase.InflationEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InflationEnsemble &lt;: EnsembleInflationFunction &lt;: InflationFunction</code></pre><p>Alias para <a href="#CPIDataBase.EnsembleFunction"><code>EnsembleFunction</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.InflationFunction" href="#CPIDataBase.InflationFunction"><code>CPIDataBase.InflationFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type InflationFunction &lt;: Function</code></pre><p>Tipo abstracto para representar las funciones de inflación que operan sobre <a href="#CPIDataBase.CountryStructure"><code>CountryStructure</code></a> y <a href="#CPIDataBase.VarCPIBase"><code>VarCPIBase</code></a>. Permiten computar la medida de ritmo inflacionario interanual, el índice de precios dado por la metodología y las variaciones intermensuales del índice de precios.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.Item" href="#CPIDataBase.Item"><code>CPIDataBase.Item</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Item{T}(code::String, name::String, weight::T&lt;:AbstractFloat)</code></pre><p>Representa un gasto básico en la estructura de nodos del IPC. Es el nivel más bajo de la estructura. Almacena el código del gasto básico, su nombre o descripción y su ponderación en el IPC. Los datos de este nodo deben estar disponibles en algún <a href="#CPIDataBase.FullCPIBase"><code>FullCPIBase</code></a>. </p><p>Posee los campos: </p><ul><li><code>code</code>: que almacena el código del gasto básico como un <code>String</code>.</li><li><code>name</code>: que almacena el nombre del gasto básico como un <code>String</code>.</li><li><code>weight::T</code>: que almacena la ponderación del gasto básico como un valor flotante de tipo <code>T</code>.</li></ul><p>Aunque este nodo será usualmente creado de manera automática por métodos como <a href="#CPIDataBase.CPITree"><code>CPITree</code></a>, se pueden crear estructuras jerárquicas manualmente. Por ejemplo, para crear un nodo del nivel inferior: </p><pre><code class="language-julia-repl hljs">julia&gt; Item(&quot;_011101&quot;, &quot;Item A&quot;, 7.352945f0)
Item{Float32}(&quot;_011101&quot;, &quot;Item A&quot;, 7.352945f0)</code></pre><p>Ver también: <a href="#CPIDataBase.Group"><code>Group</code></a>, <a href="#CPIDataBase.CPITree"><code>CPITree</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.MixedCountryStructure" href="#CPIDataBase.MixedCountryStructure"><code>CPIDataBase.MixedCountryStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MixedCountryStructure{N, T} &lt;: CountryStructure{N, T}</code></pre><p>Estructura que representa el conjunto de bases del IPC de un país,  posee el campo <code>base</code>, que es una tupla de la estructura <code>VarCPIBase</code>, cada una  con su propio tipo de índices base B. Este tipo es una colección de un tipo abstracto.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.UniformCountryStructure" href="#CPIDataBase.UniformCountryStructure"><code>CPIDataBase.UniformCountryStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformCountryStructure{N, T, B} &lt;: CountryStructure{N, T}</code></pre><p>Estructura que representa el conjunto de bases del IPC de un país,  posee el campo <code>base</code>, que es una tupla de la estructura <code>VarCPIBase</code>. Todas las bases deben tener el mismo tipo de índice base.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.VarCPIBase" href="#CPIDataBase.VarCPIBase"><code>CPIDataBase.VarCPIBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VarCPIBase{T, B} &lt;: AbstractCPIBase{T}

VarCPIBase(v::Matrix{T}, w::Vector{T}, dates::DATETYPE, baseindex::B) where {T, B}</code></pre><p>Contenedor genérico para de variaciones intermensuales de índices de precios del IPC de un país. Se representa por:</p><ul><li>Matriz de variaciones intermensuales <code>v</code>. En las filas contiene los períodos y en las columnas contiene los gastos básicos.</li><li>Vector de ponderaciones <code>w</code> de los gastos básicos.</li><li>Fechas correspondientes <code>dates</code> (por meses).</li><li>Índices base <code>baseindex</code>. </li></ul><p>Este tipo es el utilizado en el contenedor de bases del IPC de un país, denominado <a href="#CPIDataBase.CountryStructure"><code>CountryStructure</code></a>, ya que con los datos de un <code>VarCPIBase</code> es suficiente para computar cualquier medida de inflación basada en índices de precios individuales o en un estadístico de resumen de las variaciones intermensuales (como un percentil, o una media truncada).</p><p>El tipo <code>T</code> representa el tipo de datos para representar los valores de punto flotante. El tipo <code>B</code> representa el tipo del campo <code>baseindex</code>; por ejemplo, <code>Float32</code> o <code>Vector{Float32}</code>.</p><p>Ver también: <a href="#CPIDataBase.CountryStructure"><code>CountryStructure</code></a>, <a href="#CPIDataBase.UniformCountryStructure"><code>UniformCountryStructure</code></a>, <a href="#CPIDataBase.MixedCountryStructure"><code>MixedCountryStructure</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.VarCPIBase-Tuple{DataFrame, DataFrame}" href="#CPIDataBase.VarCPIBase-Tuple{DataFrame, DataFrame}"><code>CPIDataBase.VarCPIBase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VarCPIBase(df::DataFrame, gb::DataFrame)</code></pre><p>Este constructor devuelve una estructura <code>VarCPIBase</code> a partir del DataFrame  de índices de precios <code>df</code>, que contiene en las columnas las categorías o gastos  básicos del IPC y en las filas los períodos por meses. Las ponderaciones se obtienen  de la estructura <code>gb</code>, en la tercera columna de ponderaciones.</p><p>Para conocer la estructura de los DataFrames necesarios, vea también: <a href="#CPIDataBase.FullCPIBase"><code>FullCPIBase</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{CountryStructure{N, T}}, Tuple{T}, Tuple{N}} where {N, T}" href="#Base.eltype-Union{Tuple{CountryStructure{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype(::CountryStructure{N, T})</code></pre><p>Tipo de dato de punto flotante del contenedor de la estructura de país <code>CountryStructure</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{CPITree, AbstractString}" href="#Base.getindex-Tuple{CPITree, AbstractString}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(cpitree::CPITree, code::AbstractString)</code></pre><p>Este método se utiliza para indexar el árbol jerárquico <code>cpitree</code> y obtener una estructura similar cuyo nodo superior sea el nodo con el código provisto <code>code</code>. Por ejemplo, si tenemos el siguiente árbol: </p><pre><code class="language-julia-repl hljs">julia&gt; tree
CPITree{Group{Group{Group{Group{Item{Float32}, Float32}, Float32}, Float32}, Float32}} con datos
└─→ FullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03
_0: IPC [100.0]
├─ _01: Div._01 [21.491905]
│  └─ _011: Agr._011 [21.491905]
│     ├─ _0111: Subgr._0111 [7.352945]
│     │  └─ _011101: Item A [7.352945]
│     └─ _0112: Subgr._0112 [14.13896]
│        ├─ _011201: Item B [6.7442417]
│        └─ _011202: Item C [7.394718]
├─ _02: Div._02 [3.0530455]
│  ├─ _021: Agr._021 [1.1036392] 
│  │  └─ _0211: Subgr._0211 [1.1036392]
│  │     └─ _021101: Item D [1.1036392]
│  └─ _022: Agr._022 [1.9494063]
│     └─ _0221: Subgr._0221 [1.9494063]
│        └─ _022101: Item E [1.9494063]
├─ _03: Div._03 [11.68543]
│  └─ _031: Agr._031 [11.68543]
│     └─ _0311: Subgr._0311 [11.68543]
│        └─ _031101: Item F [11.68543]
└─ _04: Div._04 [63.769615]
   └─ _041: Agr._041 [63.769615]
      ├─ _0411: Subgr._0411 [16.103952]
      │  └─ _041101: Item G [16.103952]
      ├─ _0412: Subgr._0412 [28.824577]
      │  ├─ _041201: Item H [11.367162]
      │  └─ _041202: Item I [17.457417]
      └─ _0413: Subgr._0413 [18.841085]
         └─ _041301: Item J [18.841085]</code></pre><p>Al indexar por un código, como <code>_041</code>, obtenemos una estructura similar a partir de ese nodo:</p><pre><code class="language-julia-repl hljs">julia&gt; tree[&quot;_041&quot;]
CPITree{Group{Group{Item{Float32}, Float32}, Float32}} con datos
└─→ FullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03
_041: Agr._041 [63.769615]
├─ _0411: Subgr._0411 [16.103952]
│  └─ _041101: Item G [16.103952] 
├─ _0412: Subgr._0412 [28.824577]
│  ├─ _041201: Item H [11.367162]
│  └─ _041202: Item I [17.457417]
└─ _0413: Subgr._0413 [18.841085]
   └─ _041301: Item J [18.841085]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{CountryStructure, Date, Date}" href="#Base.getindex-Tuple{CountryStructure, Date, Date}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(cst::CountryStructure, startdate::Date, finaldate::Date)</code></pre><p>Devuelve una copia del <code>CountryStructure</code> con las bases modificadas para tener observaciones entre las fechas indicada por <code>startdate</code> y <code>finaldate</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{CountryStructure, Date}" href="#Base.getindex-Tuple{CountryStructure, Date}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(cst::CountryStructure, finaldate::Date)</code></pre><p>Devuelve una copia del <code>CountryStructure</code> hasta la fecha indicada por <code>finaldate</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{CountryStructure, Int64}" href="#Base.getindex-Tuple{CountryStructure, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(cst::CountryStructure, i::Int)</code></pre><p>Devuelve la base número <code>i</code> de un contenedor <code>CountryStructure</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.capitalize" href="#CPIDataBase.capitalize"><code>CPIDataBase.capitalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">capitalize(v::AbstractVector, base_index::Real = 100)
capitalize(vmat::AbstractMatrix, base_index::Real = 100)
capitalize(vmat::AbstractMatrix, base_index::AbstractVector)</code></pre><p>Función para encadenar un vector o matriz con variaciones intermensuales de índices de precios <code>v</code> o <code>vmat</code> para conformar un índice de precios cuyo valor base sea <code>base_index</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.capitalize!" href="#CPIDataBase.capitalize!"><code>CPIDataBase.capitalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">capitalize!(idx:: AbstractVector, v::AbstractVector, base_index::Real)
capitalize!(vmat::AbstractMatrix, base_index = 100)</code></pre><p>Función para encadenar un vector o matriz con variaciones intermensuales de índices de precios <code>v</code> o <code>vmat</code> para conformar un índice de precios cuyo valor base sea <code>base_index</code> y sea almacenado en <code>idx</code> o en la propia matriz <code>vmat</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.capitalize-Tuple{VarCPIBase}" href="#CPIDataBase.capitalize-Tuple{VarCPIBase}"><code>CPIDataBase.capitalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">capitalize(base::VarCPIBase)</code></pre><p>Esto devuelve una nueva instancia (copia) de tipo <code>IndexCPIBase</code> de un objeto <code>VarCPIBase</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.components-Tuple{CombinationFunction}" href="#CPIDataBase.components-Tuple{CombinationFunction}"><code>CPIDataBase.components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">components(inflfn::CombinationFunction)</code></pre><p>Devuelve un <code>DataFrame</code> con las componentes de la función de combinación lineal y las ponderaciones asociadas.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.components-Tuple{EnsembleFunction}" href="#CPIDataBase.components-Tuple{EnsembleFunction}"><code>CPIDataBase.components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">components(inflfn::EnsembleFunction)</code></pre><p>Devuelve un <code>DataFrame</code> con las componentes del <code>EnsembleFunction</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.compute_index-Tuple{CPITree, AbstractString}" href="#CPIDataBase.compute_index-Tuple{CPITree, AbstractString}"><code>CPIDataBase.compute_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_index(cpitree::CPITree [, code::AbstractString])</code></pre><p>Permite computar el índice de precios de la jerarquía provista en <code>code</code>. Si se omite <code>code</code>, se computa la jerarquía padre de la estructura <code>cpitree</code>. Si el nodo no se encuentra en el árbol, devuelve <code>nothing</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; tree
CPITree{Group{Group{Group{Group{Item{Float32}, Float32}, Float32}, Float32}, Float32}} con datos
└─→ FullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03
_0: IPC [100.0]
├─ _01: Div._01 [21.491905]
│  └─ _011: Agr._011 [21.491905]
│     ├─ _0111: Subgr._0111 [7.352945]
│     │  └─ _011101: Item A [7.352945]
│     └─ _0112: Subgr._0112 [14.13896]
│        ├─ _011201: Item B [6.7442417]
│        └─ _011202: Item C [7.394718]
├─ _02: Div._02 [3.0530455]
│  ├─ _021: Agr._021 [1.1036392]
│  │  └─ _0211: Subgr._0211 [1.1036392]
│  │     └─ _021101: Item D [1.1036392]
│  └─ _022: Agr._022 [1.9494063]
│     └─ _0221: Subgr._0221 [1.9494063]
│        └─ _022101: Item E [1.9494063]
├─ _03: Div._03 [11.68543]
│  └─ _031: Agr._031 [11.68543]
│     └─ _0311: Subgr._0311 [11.68543]
│        └─ _031101: Item F [11.68543]
└─ _04: Div._04 [63.769615]
   └─ _041: Agr._041 [63.769615]
      ├─ _0411: Subgr._0411 [16.103952]
      │  └─ _041101: Item G [16.103952]
      ├─ _0412: Subgr._0412 [28.824577]
      │  ├─ _041201: Item H [11.367162]
      │  └─ _041202: Item I [17.457417]
      └─ _0413: Subgr._0413 [18.841085]
         └─ _041301: Item J [18.841085]

julia&gt; compute_index(tree, &quot;_041&quot;)
36-element Vector{Float32}:
 100.13899
 100.2787
 100.41912
 100.560234
 100.70207
 100.84464
 100.98792
   ⋮
 104.65377
 104.81638
 104.97984
 105.14412
 105.309235
 105.47519

julia&gt; compute_index(tree[&quot;_041&quot;])
36-element Vector{Float32}:
 100.13899
 100.2787
 100.41912
 100.560234
 100.70207
 100.84464
 100.98792
   ⋮
 104.65377
 104.81638
 104.97984
 105.14412
 105.309235
 105.47519

julia&gt; a = tree[&quot;_041302&quot;]

julia&gt; a === nothing
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.cpi_tree_nodes-Tuple{Vector{&lt;:AbstractString}}" href="#CPIDataBase.cpi_tree_nodes-Tuple{Vector{&lt;:AbstractString}}"><code>CPIDataBase.cpi_tree_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cpi_tree_nodes(codes::Vector{&lt;:AbstractString}; 
    characters::(NTuple{N, Int} where N), depth::Int=1, chars::Int=characters[depth], prefix::AbstractString=&quot;&quot;, 
    base::FullCPIBase, 
    group_names::Vector{&lt;:AbstractString}, 
    group_codes::Vector{&lt;:AbstractString})</code></pre><p>Construye y devuelve una lista de nodos a partir de la lista de códigos <code>codes</code> o de la especificación jerárquica de caracteres en <code>characters</code>. Los nombres y las ponderaciones del nivel inferior (nivel de gasto básico) son obtenidas de la estructura <code>base</code>. Se debe proveer el vector de códigos y nombres de todas las jerarquías superiores en la estructura de códigos en los vectores <code>group_names</code> y <code>group_codes</code>.</p><p>Esta función permite crear únicamente la estructura jerárquica de nodos. Para construir de manera automática una estructura del IPC, se recomienda utilizar preferentemente <a href="#CPIDataBase.CPITree"><code>CPITree</code></a>.</p><p>Vea también: <a href="#CPIDataBase.CPITree"><code>CPITree</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.get_cpi_tree-Tuple{}" href="#CPIDataBase.get_cpi_tree-Tuple{}"><code>CPIDataBase.get_cpi_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_cpi_tree(; 
    base::FullCPIBase, 
    group_names::Vector{&lt;:AbstractString}, 
    group_codes::Vector{&lt;:AbstractString}, 
    characters::(NTuple{N, Int} where N),
    upperlevel_code = &quot;_0&quot;, 
    upperlevel_name = &quot;IPC&quot;)</code></pre><p>Función superior para obtener estructura jerárquica del IPC. Devuelve el nodo superior del árbol jerárquico. Utiliza la función de más bajo nivel <code>cpi_tree_nodes</code> para construir los nodos del nivel más alto y hacia abajo en la estructura jerárquica. Se debe proveer el vector de códigos y nombres de todas las jerarquías superiores en la estructura de códigos en los vectores <code>group_names</code> y <code>group_codes</code>. </p><p>Esta función permite crear únicamente la estructura jerárquica de nodos. Para construir de manera automática una estructura del IPC, se recomienda utilizar preferentemente <a href="#CPIDataBase.CPITree"><code>CPITree</code></a>.</p><p>Vea también: <a href="#CPIDataBase.CPITree"><code>CPITree</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.getdates-Tuple{Date, AbstractMatrix}" href="#CPIDataBase.getdates-Tuple{Date, AbstractMatrix}"><code>CPIDataBase.getdates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getdates(startdate::Date, vmat::AbstractMatrix)</code></pre><p>Obtiene un rango de fechas a partir de una fecha inicial <code>startdate</code> y la cantidad de períodos en la matriz de variaciones intermensuales <code>vmat</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.getdates-Tuple{Date, Int64}" href="#CPIDataBase.getdates-Tuple{Date, Int64}"><code>CPIDataBase.getdates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getdates(startdate::Date, periods::Int)</code></pre><p>Obtiene un rango de fechas a partir de una fecha inicial <code>startdate</code> y la cantidad de períodos de una matriz de variaciones intermensuales </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.getunionalltype-Tuple{MixedCountryStructure}" href="#CPIDataBase.getunionalltype-Tuple{MixedCountryStructure}"><code>CPIDataBase.getunionalltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getunionalltype(::MixedCountryStructure)</code></pre><p>Devuelve el tipo <code>MixedCountryStructure</code>. Utilizado al llamar <code>getunionalltype</code> sobre un <code>CountryStructure</code> para obtener el tipo concreto <code>UnionAll</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.getunionalltype-Tuple{UniformCountryStructure}" href="#CPIDataBase.getunionalltype-Tuple{UniformCountryStructure}"><code>CPIDataBase.getunionalltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getunionalltype(::UniformCountryStructure)</code></pre><p>Devuelve el tipo <code>UniformCountryStructure</code>. Utilizado al llamar <code>getunionalltype</code> sobre un <code>CountryStructure</code> para obtener el tipo concreto <code>UnionAll</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.infl_dates-Tuple{CountryStructure}" href="#CPIDataBase.infl_dates-Tuple{CountryStructure}"><code>CPIDataBase.infl_dates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infl_periods(cst::CountryStructure)</code></pre><p>Fechas correspondientes a la trayectorias de inflación computadas a partir un <code>CountryStructure</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.infl_periods-Tuple{CountryStructure}" href="#CPIDataBase.infl_periods-Tuple{CountryStructure}"><code>CPIDataBase.infl_periods</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infl_periods(cst::CountryStructure)</code></pre><p>Computa el número de períodos de inflación de la estructura de país. Corresponde al número de observaciones intermensuales menos las primeras 11 observaciones de la primera base del IPC.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.measure_name-Tuple{InflationFunction}" href="#CPIDataBase.measure_name-Tuple{InflationFunction}"><code>CPIDataBase.measure_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure_name(inflfn::InflationFunction)</code></pre><p>Este método permite obtener el nombre convencional de una medida de inflación. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.measure_tag-Tuple{InflationFunction}" href="#CPIDataBase.measure_tag-Tuple{InflationFunction}"><code>CPIDataBase.measure_tag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure_tag(inflfn::InflationFunction)</code></pre><p>Obtiene una etiqueta de la medida de inflación. Se puede utilizar para guardar como parámetro en archivos de resultados de evaluación.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.num_measures-Tuple{InflationFunction}" href="#CPIDataBase.num_measures-Tuple{InflationFunction}"><code>CPIDataBase.num_measures</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_measures(::InflationFunction)</code></pre><p>Devuelve la cantidad de medidas devueltas por la función de inflación. Las funciones de <a href="#CPIDataBase.EnsembleFunction"><code>EnsembleFunction</code></a> pueden computar varias medidas de inflación simultáneamente.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.params-Tuple{InflationFunction}" href="#CPIDataBase.params-Tuple{InflationFunction}"><code>CPIDataBase.params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">params(inflfn::InflationFunction)</code></pre><p>Método para obtener parámetros de la función de inflación. Devuelve una tupla con el conjunto de parámetros utilizado por la función de inflación <code>inflfn</code>. Este método debe redefinirse en las nuevas medidas de inflación si estas están parametrizadas.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.periods-Tuple{CountryStructure}" href="#CPIDataBase.periods-Tuple{CountryStructure}"><code>CPIDataBase.periods</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">periods(cst::CountryStructure)</code></pre><p>Computa el número de períodos (meses) en las bases de variaciones intermensuales de la estructura de país. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.periods-Tuple{VarCPIBase}" href="#CPIDataBase.periods-Tuple{VarCPIBase}"><code>CPIDataBase.periods</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">periods(base::VarCPIBase)</code></pre><p>Computa el número de períodos (meses) en las base de variaciones intermensuales. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.varinteran" href="#CPIDataBase.varinteran"><code>CPIDataBase.varinteran</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">varinteran(idx::AbstractVector, base_index::Real = 100) -&gt; Vector{&lt;:AbstractFloat}
varinteran(cpimat::AbstractMatrix, base_index::Real = 100) -&gt; Matrix{&lt;:AbstractFloat}
varinteran(cpimat::AbstractMatrix, base_index::AbstractVector) -&gt; Matrix{&lt;:AbstractFloat}</code></pre><p>Obtiene variaciones interanuales del vector <code>idx</code> o de la matriz <code>cpimat</code> utilizando como índice base el número o vector <code>base_index</code>. </p><ul><li>Si <code>base_index</code> es un vector, se obtienen las variaciones interanuales utilizando diferentes índices base para cada columna de <code>cpimat</code>. El vector <code>base_index</code> debe tener la misma cantidad de columnas que <code>cpimat</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.varinteran!" href="#CPIDataBase.varinteran!"><code>CPIDataBase.varinteran!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">varinteran!(v::AbstractVector, idx::AbstractVector, base_index::Real = 100) -&gt; Vector{&lt;:AbstractFloat}</code></pre><p>Computa las variaciones interanuales del vector <code>idx</code> utilizando como índice base <code>base_index</code>. Si se provee <code>v</code>, los resultados son guardados en este vector, en vez del mismo <code>idx</code>.</p><ul><li>El vector <code>v</code> tiene 11 observaciones menos que <code>idx</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.varinterm" href="#CPIDataBase.varinterm"><code>CPIDataBase.varinterm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">varinterm(idx::AbstractVecOrMat, base_index = 100)</code></pre><p>Función para computar un vector o una matriz de variaciones intermensuales de los índices de precios en <code>idx</code>, utilizando como índice base <code>base_index</code> en la primera observación. </p><p>Ver también: <a href="#CPIDataBase.varinterm!"><code>varinterm!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.varinterm!" href="#CPIDataBase.varinterm!"><code>CPIDataBase.varinterm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">varinterm!([v::AbstractVecOrMat, ] idx::AbstractVecOrMat, base_index = 100)</code></pre><p>Función para computar un vector o una matriz de variaciones intermensuales de los índices de precios en <code>idx</code>, utilizando como índice base <code>base_index</code> en la primera observación. Si <code>idx</code> es una matriz, <code>v</code> es opcional y el cómputo se realiza sobre la misma matriz. Si <code>idx</code> es un vector, es necesario proporcionar <code>v</code> para realizar el cómputo.</p><p>Ver también: <a href="#CPIDataBase.varinterm"><code>varinterm</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.varinterm-Tuple{IndexCPIBase}" href="#CPIDataBase.varinterm-Tuple{IndexCPIBase}"><code>CPIDataBase.varinterm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">varinterm(base::IndexCPIBase)</code></pre><p>Devuelve una nueva copia de tipo <code>VarCPIBase</code> de un <code>IndexCPIBase</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.weights-Tuple{CombinationFunction}" href="#CPIDataBase.weights-Tuple{CombinationFunction}"><code>CPIDataBase.weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weights(combfn::CombinationFunction)</code></pre><p>Devuelve el vector de ponderaciones de una <a href="#CPIDataBase.CombinationFunction"><code>CombinationFunction</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.TestHelpers.getbasedates" href="#CPIDataBase.TestHelpers.getbasedates"><code>CPIDataBase.TestHelpers.getbasedates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getbasedates(vmat, startdate=Date(2000, 12))</code></pre><p>Función para generar fechas a partir de matriz de variaciones intermensuales</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.TestHelpers.getrandombase-Tuple{}" href="#CPIDataBase.TestHelpers.getrandombase-Tuple{}"><code>CPIDataBase.TestHelpers.getrandombase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getrandombase(; 
    [T_type = Float32, 
    G = 218, 
    T_periods = 120, 
    startdate = Date(2001,1), 
    baseindex = 100*one(T_type)])</code></pre><p>Función para obtener una base de tipo <code>VarCPIBase</code> con variaciones intermensuales aleatorias.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.TestHelpers.getrandomcountryst" href="#CPIDataBase.TestHelpers.getrandomcountryst"><code>CPIDataBase.TestHelpers.getrandomcountryst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getrandomcountryst(T_type = Float32)</code></pre><p>Obtiene un <code>UniformCountryStructure</code> cuyas variaciones intermensuales son todas aleatorias en la configuración de períodos del IPC de Guatemala.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.TestHelpers.getrandomweights" href="#CPIDataBase.TestHelpers.getrandomweights"><code>CPIDataBase.TestHelpers.getrandomweights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getrandomweights(T=Float32, G=218)</code></pre><p>Función para generar pesos aleatorios </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.TestHelpers.getzerobase-Tuple{}" href="#CPIDataBase.TestHelpers.getzerobase-Tuple{}"><code>CPIDataBase.TestHelpers.getzerobase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getzerobase(; 
    [T_type = Float32, 
    G = 218, 
    T_periods = 120, 
    startdate = Date(2001,1), 
    baseindex = 100*one(T_type)])</code></pre><p>Función para obtener base de tipo <code>VarCPIBase</code> con variaciones intermensuales iguales a cero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CPIDataBase.TestHelpers.getzerocountryst" href="#CPIDataBase.TestHelpers.getzerocountryst"><code>CPIDataBase.TestHelpers.getzerocountryst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getzerocountryst(T_type = Float32)</code></pre><p>Obtiene un <code>UniformCountryStructure</code> cuyas variaciones intermensuales son todas iguales a cero en la configuración de períodos del IPC de Guatemala.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../HEMI/">« HEMI</a><a class="docs-footer-nextpage" href="../InflationFunctions/">InflationFunctions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Wednesday 15 June 2022 17:30">Wednesday 15 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
